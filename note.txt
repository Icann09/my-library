What problem does it solve?
"This application solves the problem of managing a digital library system with clearly separated responsibilities between regular users and administrators. 
It allows users to securely search, borrow, and track books, while enabling administrators to manage inventory, user permissions, and borrowing workflows in a controlled, role-based environment. 
The system includes background workflows for overdue reminders using Upstash Workflows, enabling reliable, serverless email notifications independent of user activity.
Data is stored in a relational database using neon-prostegreSQL (with drizzle ORM) with clear separation between user, book, and borrowing entities, ensuring consistent authorization checks at the query level."


Architecture decision 
"The application is built using a layered, server-first architecture with Next.js App Router. Server-side rendering, authentication, and role-based access control are handled on the server, while interactive UI and local state are managed on the client."

Core Architectural Decisions

1. App Router + Server Components (Server-first)
I used Next.js App Router to leverage Server Components for data fetching and page rendering, ensuring secure access to authentication data and improving performance by reducing client-side JavaScript.

2. Session-Based Authentication (Server-Side)
Authentication is handled using session-based auth stored in HttpOnly cookies, allowing secure user identification on every request without exposing tokens to the client.
z
3. Role-Based Access Control (RBAC)
I implemented role-based access control by validating user roles at the layout and server-action level, ensuring that admin-only routes and mutations cannot be accessed from the client.

4. Data Fetching and Server Actions for Mutations
All data fetching, create, update, and delete operations are implemented using Server Actions instead of API routes, reducing boilerplate and keeping business logic on the server.

5.URL-Based State & Search
Search and filtering are driven by URL query parameters, enabling shareable, bookmarkable pages while keeping server-rendered data in sync with client interactions.



üîç Trade-offs & Technical Decisions
Server Actions vs API Routes

Why Server Actions
. Reduced boilerplate by colocating mutations with business logic
. Automatic server-side authentication and authorization
. Type-safe mutations without manual request/response handling
. Better alignment with Next.js App Router architecture

Trade-offs
. Tighter coupling to Next.js (less framework-agnostic)
. Limited reusability for external consumers (e.g. mobile apps)
. Requires careful handling of optimistic UI and error states

Decision
. Server Actions were chosen to prioritize security, maintainability, and developer productivity for a web-only application.



‚ö†Ô∏è Challenges Faced
1. Server vs Client Boundaries
. Managing clear separation between Server Components and Client Components
. Avoiding accidental client-side access to sensitive authentication data
Solution
. Centralized auth logic in server-only utilities
. Enforced role checks at layout and server-action levels

2. Role-Based Access Control
. Preventing privilege escalation beyond UI restrictions
Solution
. Role validation performed on the server for every protected route and mutation
. UI checks used only as a convenience layer

3. Background Workflows & Due Date Notifications
Challenge
. Handling time-based workflows (book due reminders) without relying on client-side logic
. Ensuring notifications are reliable even when users are inactive or offline
. Avoiding long-running cron jobs or custom background servers
‚úÖ Solution: Upstash Workflow + Email Notifications
. Implemented Upstash Workflows to manage delayed and scheduled background tasks
. When a book is borrowed, a workflow is triggered that:
. Calculates the due date
. Schedules reminder steps (e.g. 3 days before due, on due date, overdue)
. Sends email notifications automatically without user interaction
. Workflow execution is durable, retry-safe, and serverless-friendly